

Московский государственный университет имени М.В. Ломоносова

Факультет вычислительной математики и кибернетики

Отчет по предмету:

Параллельная обработка данных в научных исследованиях

Де Ен Де, 508

Москва, 2023





**Содержание**

\1. Постановка задачи

3

4

\2. Вычисление характеристик

\3. Метод оптимизации

\4. Описание программы

\5. Распараллеливание программы

\6. Анализ полученных параметров

\7. Заключение

8

10

14

17

18

19

\8. Приложение





**1. Постановка задачи**

Требуется определить потенциалы межатомного взаимодействия

А-А, А-В и В-В для системы А/В(001). Виды потенциалов:

\-

\-

\-

E – полная энергия системы;

퐸 푖 и 퐸 푖 – энергии отталкивания и притяжения i-ого атома

푅

퐵

푟푖푗 – расстояние между i-ым и j-ым атомами;

\-

– параметры потенциалов

Расчеты полной энергии проводятся для кристаллической решетки

размером 3х3х3 в единицах элементарной ячейки ГЦК. Все расчеты

проводятся без релаксации атомных позиций. Атомы располагаются в

узлах идеальной ГЦК решетки





**2. Вычисление характеристик**

Гранецентрированная кубическая решетка(ГЦК) представлена на

рис. 1a). Для построения решетки нужно выделить элементарную ячейку,

состоящей из 4 базисных атомов (0,0,0), (0.5푎, 0.5푎, 0), (0.5푎, 0, 0.5푎) и

(0, 0.5푎, 0.5푎) (атомы выделены желтым цветом). Далее необходимо

размножить элементарную ячейку до решетки 3х3х3, как указано на

рисунке 1.





Для решения задачи необходимо найти набор параметров модельного

потенциала, который позволит получить заданные характеристики материала.

Построим функцию оптимизации как взвешенную сумму квадратов отклонений

характеристик.

Функционал имеет следующий вид:

, где

\-

\-

f (params) – вычисленные значения;

f\*– эталонные значения.

Рассмотрим характеристики материала:

\1. a – параметр решетки, который находится как точка минимума полной

энергии системы 퐸 по 5 точкам из возможного диапазона значений;

\2. 퐸푐표ℎ – когезионная энергия, которая вычисляется по следующей

формуле:

\-

\-

퐸 – полная энергия;

푁 – количество атомов в решетке;

\3. B – модуль всестороннего растяжения/сжатия:

\-

푉0 – равновесный объем;

Для вычисления этого параметра была использована матрица

деформации, которая имеет следующий вид:





\4. 퐶 , 퐶 , 퐶 – константы упругости:

11

12

44

Для вычисления этих параметров были использованы матрицы

деформации, которые имеют следующий вид:

퐷11 =

퐷12 =

퐷44 =

\5. 퐸푠표푙 – энергия растворимости примеси рода А в кристалле рода В:

\-

퐸퐴퐵 – полная энергия кристаллической решетки В с примесью

замещения А;

\-

\-

\-

퐸퐵 – полная энергия кристаллической решетки В;

EAcoh – когезионная энергия А (берется из справочника);

EBcoh – когезионная энергия В;





\6. Edimin – энергия связи димера А в поверхностном слое В:

\-

\-

\-

Edim+surf – полная энергия структуры поверхности с димером А в

верхнем слое;

Eadatom+surf – полная энергия структуры поверхности с одним атомом

А в верхнем слое;

Esurf – полная энергия структуры поверхности;

\7. Edimon – энергия связи димера А на поверхности В:

\-

\-

\-

Edim+surf – полная энергия структуры поверхности с димером А над

верхним слоем;

Eadatom+surf – полная энергия структуры поверхности с одним атомом

А над верхним слоем;

Esurf – полная энергия структуры поверхности;





**3. Метод оптимизации**

Для решения задачи оптимизации в работе используется метод

Нелдера-Мида. Рассмотрим его алгоритм.

В основе этого метода лежит движении симплекса в пространстве

параметров в сторону локального минимума целевой функции.

Параметрами метода являются:

\-

\-

\-

\-

Коэффициент отражения 훼 > 0, обычно выбирается равным 1.

Коэффициент сжатия 훽 > 0, обычно выбирается равным 0.5.

Коэффициент растяжения 훾 > 0, обычно выбирается равным 2.

Коэффициент глобального сжатия 휎 > 0, обычно выбирается

равным 0.5.

\1. Инициализация метода. Случайным образом выбираются 푛푛 + 1 точка

в 푛푛 - мерном пространстве параметров, образующие симплекс, и в

них вычисляются значения целевого функционала:

\2. . Выберем из вершин симплекса три: 푥 , 푥 и 푥 , такие что 푓 —

ℎ

푔

푙

ℎ

наибольшее значение целевой функции из всех вершин симплекса, 푓푔

— второе по величине значение и 푓푙 — наименьшее.

\3. Найдём центр тяжести всех точек за исключением 푥ℎ :

\4. Отразим точку 푥 относительно точки 푥 с коэффициентом 훼. Получим

ℎ

푐

таким образом точку 푥 = (1 + 훼)푥 − 훼푥 и вычислим в ней значение

푟

푐

ℎ

целевого функционала 푓푟.

\5. Проверим насколько нам удалось улучшить значение функции:





\-

푓 < 푓 — направление выбрано удачно, попробуем увеличить шаг.

푟 푙

Вычислим новую точку 푥 = (1 − 훾)푥 + 훾푥 и значение функции в ней

푒

푐

푟

푓 . Из точек 푥 и 푥 выбираем наилучшую и заменяем ею 푥 .

푒

푟

푒

ℎ

\-

\-

푓 ≤ 푓 < 푓 — новая точка улучшает ответ, заменим ею 푥 .

푙 푟 푔

ℎ

푓 ≤ 푓 < 푓 — новая точка улучшает ответ, но слабо, заменим ею 푥 и

푔

푟

ℎ

ℎ

проведём операцию сжатия.

\-

푓 ≤ 푓 — новая точка не улучшает ответ, проведём операцию сжатия.

ℎ

푟

\6. Сжатие. Если было решено провести операцию сжатия, то построим

новую точку 푥 = (1 − 훽)푥 + 훽푥 и вычислим значение функции в ней

푠

푐

ℎ

푓 .

푠

\-

\-

푓 < 푓 — заменяем вершину 푥 точкой 푥 .

푠 푠

ℎ ℎ

푓 ≤ 푓 — сжимаем весь симплекс к точке с наименьшим значением 푥

푖

ℎ

푠

← 푥 + 휎(푥 − 푥 ).

푙

푖

푙





**4. Описание программы**

Программа на вход ничего не принимает. Конфигурационные данные берутся из

файла Const.hpp.

Выходными данными программы является вывод, в котором указаны

полученные параметры потенциалов для трех взаимодействий (А-А, А-В, В-В).

Пример вывода программы:

B-B: A0 = 0.1028; A1 = 1.17054e-310; ksi = 1.178; p = 10.928; q = 3.139; a0 = 4.085

A-B: A0 = 0.169988; A1 = 0.233594; ksi = 1.41237; p = 11.2608; q = 3.27181; a0 =

3.68578

A-A: A0 = 0.0457012; A1 = 0.00583804; ksi = 1.72314; p = 10.8348; q = 3.38821; a0

= 4.50424

Также программа выводит значений целевой функции и параметры для данной

ошибки.

Error: 0.668221A0 = 0.17155; A1 = 0.234375; ksi = 1.4155; p = 11.2593; q =

3.27025; a0 = 3.68812

Программа состоит из 12 файлов:

Dot.cpp, EnergyFun.cpp, Optimizer.cpp, Parameters.cpp, main.cpp, Const.hpp,

DeformParams.hpp, Dot.hpp, EnergyFun.hpp, Optimizer.hpp, Parameters.hpp,

Params.hpp

Также для сборки присутствует программы Makefile

Основные классы и структуры:

**//Dot - координаты атома и признак того, является ли атом примесью**

**struct** Dot {

**double** x, y, z;

**bool** isDim = **false**;

Dot& **operator**-= (**const** Dot& o);

Dot& **operator**\*= (**double** o);

Dot **friend operator**-(**const** Dot& lhs, **const** Dot& rhs);

Dot **friend operator**\*(**const** Dot& lhs, **double** rhs);

Dot **friend operator**\*(**double** lhs, **const** Dot& rhs);

**friend bool operator**==(**const** Dot &lhs, **const** Dot &right);

**friend bool operator**==(**const** Dot \*lhs, **const** Dot &right);

**friend** std::ostream &**operator**<<(std::ostream &out, **const** Dot &d);





};

**// DeformParams - структура хранящая модуль всестороннего растяжения и**

**константы упругости**

**struct** DeformParams {

**double** B;

**double** C11;

**double** C12;

**double** C44;

};

// Parameters - класс для работы с параметрами, которые будут

оптимизироваться

**class** Parameters

{

**private**:

**double** A0;

**double** A1;

**double** p;

**double** ksi;

**double** q;

**double** a0;

**public**:

**double** getA0() **const**;

**double** getA1() **const**;

**double** getP() **const**;

**double** getKsi() **const**;

**double** getQ() **const**;

**double** getCubeSide() **const**;

Parameters &withA0(**const double** &A0);

Parameters &withA1(**const double** &A1);

Parameters &withP(**const double** &p);

Parameters &withKsi(**const double** &ksi);

Parameters &withQ(**const double** &q);

Parameters &withCubeSide(**const double** &a0);

Parameters **operator**+(**const** Parameters &rhs);

Parameters **operator**\*(**const double** &dig);

Parameters **operator**-(**const** Parameters &rhs);

Parameters &**operator**+=(**const** Parameters &rhs);

Parameters &**operator**/=(**const double** &dig);

**friend** std::ostream &**operator**<<(std::ostream &out, **const** Parameters

&param);

};





//Optimizer - класс, выполняющий задачу оптимизации методом Нелдера-Мида

**class** Optimizer

{

**private**:

std::multimap<**double**, Parameters> simplex;

Parameters BBParams;

Parameters ABParams;

Parameters AAParams;

**double** ref\_coef = 1.0;

**double** compr\_coef = 1.0;

**double** stretch\_coef = 0.5;

**double** glob\_compr\_coef = 0.5;

**void** shrink(Parameters &x\_c, Parameters &x\_h, Parameters &x\_l, **const**

**double** &f\_h, **double** (\* error)(**const** Parameters &params));

**public**:

**static double** errorBB(**const** Parameters &params);

**static double** errorAB(**const** Parameters &params);

**static double** errorAA(**const** Parameters &params);

**void** initBB();

**void** initAB();

**void** initAA();

**void** step(**double** (\* error)(**const** Parameters &params));

**void** run();

**const** Parameters &getAAParams() **const**;

**const** Parameters &getABParams() **const**;

**const** Parameters &getBBParams() **const**;

};





Схема работы программы





**5. Распараллеливание программы**

Одной из самых затратных операций является подсчет полной

энергии кристаллической решетки E. За эти вычисления отвечают

функции:

**double** countEnergy(**const** std::vector<Dot\*> &data, **const** Parameters &params,

**const double** d[9]);

**double** countSolEnergy(**const** std::vector<Dot\*> &data, **const** Parameters

&params, **const double** d[9]);

**double** countSurfEnergy(**const** std::vector<Dot\*> &data, **const** Parameters

&params, **const double** d[9]);

Данные функции используют директиву

#pragma omp parallel for reduction

Применяется она для выделения отдельного потока для каждой итерации

цикла, так как подсчет энергии взаимодействия между двумя атомами

кристаллической решетки не зависит от остальных атомов решетки. Редукция

оператором + происходит для переменной sumE, которая хранит в себе

суммарную энергию решетки.

Код программы:

**double** countEnergy(**const** std::vector<Dot\*> &data, **const** Parameters &params,

**const double** d[9]) {

**double** sumE = 0;

**double** a0 = params.getCubeSide();

**double** cutOff = CONST::CUT\_OFF \* a0;

**double** r0 = a0 / sqrt(2);

#pragma omp parallel for reduction(+: sumE)

**for** (**unsigned** i = 0; i < data.size(); ++i) {

Dot dot0 = countDefformation(\*data[i], d);

**double** curEB = 0;

**double** curER = 0;

#pragma omp parallel for reduction(+: curEB, curER)

**for** (**unsigned** j = 0; j < data.size(); ++j) {

**for** (**int** dx = -1; dx < 2; ++dx) {

**for** (**int** dy = -1; dy < 2; ++dy) {

**for** (**int** dz = -1; dz < 2; ++dz) {

**if** (i == j && dx == 0 && dy == 0 && dz == 0) {

**continue**;

}

Dot dotBorder = borderCondition(\*data[j], dx, dy,





dz, a0);

Dot dot1 = countDefformation(dotBorder, d);

**double** dist = sqrt(

pow(dot1.x - dot0.x, 2) + pow(dot1.y - dot0.y,

\2) + pow(dot1.z - dot0.z, 2)

);

**if** (dist > cutOff) {

**continue**;

}

curER += params.getA0() \* exp(-params.getP() \* (dist

/ r0 - 1));

curEB += pow(params.getKsi(), 2) \* exp(-2 \*

params.getQ() \* (dist / r0 - 1));

}

}

}

}

sumE += (-sqrt(curEB) + curER);

}

**return** sumE;

}

Использование данной директивы позволило ускорить выполнение

вычислений в несколько раз:

\-

\-

без распараллеливания: 15.78s

с распараллеливанием: 2.37s





Ресурс ЦП в однопоточном режиме

Ресурс ЦП в многопоточном режиме





**6. Анализ полученных параметров**

В ходе работы были получены оптимальные параметры:

B-B: A0 = 0.1028; A1 = 1.17054e-310; ksi = 1.178; p = 10.928; q = 3.139; a0 = 4.085

A-B: A0 = 0.169988; A1 = 0.233594; ksi = 1.41237; p = 11.2608; q = 3.27181; a0 =

3.68578

A-A: A0 = 0.0457012; A1 = 0.00583804; ksi = 1.72314; p = 10.8348; q = 3.38821; a0

= 4.50424

Для этих параметров были получены следующие значения потенциалов:

Ecoh = -2.9603 B = 1.08303 C11 = 1.31656 C12 = 0.966251 C44 = 0.506432

ESol = 0.632767

EInDim = -0.0794742 EOnDim = -0.678188

Все значения потенциалов примерно равны табличным. Также для

проверки были получены значения энергии кристаллической решетки для

каждого типа взаимодействия. Для B-B была посчитана ECoh, для A-B - ESol и

для A-A была посчитана ESurf без примеси. Значения энергий были получены

для a0 в диапазоне между [3.0; 10.0]

Полученные результаты были визуализированы средствами Python и

Matplotlib. Полученные графики имеют правильную форму и доказывают

корректность полученных параметров:





**7. Заключение**

В данной работе для поиска параметров потенциала использовался метод

Нелдера-Мида, являющийся методом нулевого порядка. Данный алгоритм не

требует сложных вычислений и потребляет много ресурсов процессора и

памяти. С другой стороны данный метод обладает большим недостатком в виде

отсутствия критерия сходимости, что может привести к неправильному

результату. Также возможна ситуация, когда рабочий симплекс находится далеко

от оптимальной точки, а алгоритм производит большое число итерации, при

этом мало изменяя значения целевой функции.

Использование параллелизма дает прирост к скорости выполнения

вычислений, что позволило быстро анализировать результаты программы в ходе

ее проектирования и написания. При более сложной структуре решетки и

большего количества элементов в ней моделирование такой системы было бы

затруднительным без использования данной технологии.

